#ifndef shogi_legality_lite_bindings_h
#define shogi_legality_lite_bindings_h

/* Warning, this file is autogenerated by cbindgen. Don't modify this manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdlib.h>


/**
 * How many elements should an array indexed by [`Color`] have?
 *
 * Examples:
 * ```
 * # use shogi_core::Color;
 * // values is long enough so values[color.index()] never panics
 * let mut values = [0; Color::NUM];
 * values[Color::Black.array_index()] = 10;
 * values[Color::White.array_index()] = -10;
 * ```
 * Since: 0.1.2
 */
#define Color_NUM 2

#if defined(DEFINE_EXPERIMENTAL)
#define PieceKind_OPTION_NUM 15
#endif

/**
 * A player.
 *
 * [`Color`] and <code>[Option]<[Color]></code> are both 1-byte data types.
 * Because they are cheap to copy, they implement [`Copy`].
 */
enum Color {
  /**
   * Black, who plays first. Known as `先手` (*sente*).
   *
   * Its representation is 1.
   */
  Black = 1,
  /**
   * White, who plays second. Known as `後手` (*gote*).
   *
   * Its representation is 2.
   */
  White = 2,
};
typedef uint8_t Color;

/**
 * Kinds of pieces.
 *
 * [`PieceKind`] and <code>[Option]<[PieceKind]></code> are both 1-byte data types.
 * Because they are cheap to copy, they implement [`Copy`].
 */
enum PieceKind {
  /**
   * A pawn. Unlike in chess, it always moves one square forward,
   * even if the destination square is occuipied by an enemy piece.
   *
   * Known as `歩` (*fu*) or `歩兵` (*fuhyō*), although the latter name is rarely used.
   *
   * Discriminant = 1.
   */
  Pawn = 1,
  /**
   * A lance. It moves any number of squares forward without jumping over other pieces.
   * Chess has no counterpart of it.
   *
   * Known as `香` (*kyō*) or `香車` (*kyōsha*).
   *
   * Discriminant = 2.
   */
  Lance = 2,
  /**
   * A knight. Unlike in chess, it can only move two squares forward and one square vertically.
   *
   * Known as `桂` (*kē*) or `桂馬` (*kēma*).
   *
   * Discriminant = 3.
   */
  Knight = 3,
  /**
   * A silver general. It moves one square forward or diagonally.
   * Chess has no counterpart of it.
   *
   * Known as `銀` (*gin*) or `銀将` (*ginshō*), although the latter name is rarely used.
   *
   * Discriminant = 4.
   */
  Silver = 4,
  /**
   * A gold general. It moves one square horizontally, vertically, and diagonally forward.
   * Chess has no counterpart of it.
   *
   * Known as `金` (*kin*) or `金将` (*kinshō*), although the latter name is rarely used.
   *
   * Discriminant = 5.
   */
  Gold = 5,
  /**
   * A bishop. It moves any number of squares diagonally,
   * exactly the same way as a bishop does in chess.
   *
   * Known as `角` (*kaku*) or `角行` (*kakugyō*), although the latter name is rarely used.
   *
   * Discriminant = 6.
   */
  Bishop = 6,
  /**
   * A rook. It moves any number of squares horizontally or vertically.
   * It is almost the same as a rook in chess, but shogi has no rule of castling.
   *
   * Known as `飛` (*hi*) or `飛車` (*hisha*), although the former name is rarely used to refer to a piece.
   *
   * Discriminant = 7.
   */
  Rook = 7,
  /**
   * A king. It moves one square horizontally, vertically or diagonally.
   * A move that would expose the king to an enemy piece's capture threat is an illegal move,
   * and the player that has no legal moves immediately loses.
   *
   * It is almost the same as a king in chess, but shogi has no rule of castling.
   *
   * Known as `王` (*ō*), `王将` (*ōshō*), `玉` (*gyoku*) or `玉将` (*gyokushō*).
   * The two-letter names are rarely used to refer to pieces.
   *
   * Discriminant = 8.
   */
  King = 8,
  /**
   * A promoted pawn. Moves exactly the same way as a gold general.
   *
   * Known as `と` (*to*) or `と金` (*tokin*),
   * although the former name is rarely used to refer to a piece.
   *
   * Discriminant = 9.
   */
  ProPawn = 9,
  /**
   * A promoted lance. Moves exactly the same way as a gold general.
   *
   * Known as `成香` (*narikyō*).
   *
   * Discriminant = 10.
   */
  ProLance = 10,
  /**
   * A promoted knight. Moves exactly the same way as a gold general.
   *
   * Known as `成桂` (*narikē*).
   *
   * Discriminant = 11.
   */
  ProKnight = 11,
  /**
   * A promoted silver general. Moves exactly the same way as a gold general.
   *
   * Known as `成銀` (*narigin*).
   *
   * Discriminant = 12.
   */
  ProSilver = 12,
  /**
   * A promoted bishop. It moves any number of squares diagonally, or one square horizontally or vertically.
   *
   * Known as `馬` (*uma*), `竜馬` (*ryūma*),
   * although the latter is rarely used and confusing.
   *
   * Discriminant = 13.
   */
  ProBishop = 13,
  /**
   * A promoted rook.  It moves any number of squares horizontally or vertically, or one square diagonally.
   *
   * Known as `竜` (*ryū*), `竜王` (*ryūō*),
   * although the latter is rarely used and confusing.
   *
   * Discriminant = 14.
   */
  ProRook = 14,
};
typedef uint8_t PieceKind;

/**
 * A subset of all squares.
 *
 * Because [`Bitboard`] is cheap to copy, it implements [`Copy`].
 * Its [`Default`] value is an empty instance.
 */
typedef struct Bitboard {
  uint64_t _0[2];
} Bitboard;

/**
 * A hand of a single player. A hand is a multiset of unpromoted pieces (except a king).
 *
 * This type can hold up to 255 pieces of each kind, although the rule of shogi prohibits it.
 *
 * Because [`Hand`] is cheap to copy, it implements [`Copy`](https://doc.rust-lang.org/core/marker/trait.Copy.html).
 * Its [`Default`] value is an empty instance.
 */
typedef struct Hand {
  uint8_t _0[8];
} Hand;
/**
 * The number of all valid pieces in hand.
 *
 * Examples:
 * ```
 * # use shogi_core::Hand;
 * assert_eq!(Hand::all_hand_pieces().count(), Hand::NUM_HAND_PIECES);
 * ```
 * Since: 0.1.2
 */
#define Hand_NUM_HAND_PIECES 7

/**
 * C-compatible type for <code>[Option]<[Piece]></code> with defined representations.
 *
 * Valid representations are `0..=14`, and `17..=30`. `0` represents [`None`], `1..=14` represents a black [`Piece`] and `17..=30` represents a white [`Piece`].
 *
 * cbindgen cannot deduce that <code>[Option]<[Piece]></code> can be represented by `uint8_t` in C, so we need to define the bridge type.
 * See: <https://github.com/eqrion/cbindgen/issues/326>
 */
typedef uint8_t OptionPiece;

/**
 * C-compatible type for <code>[Option]<[CompactMove]></code>.
 *
 * cbindgen cannot deduce that <code>[Option]<[CompactMove]></code> can be represented by `uint16_t` in C, so we need to define the bridge type.
 * See: <https://github.com/eqrion/cbindgen/issues/326>.
 */
typedef uint16_t OptionCompactMove;

/**
 * C interface of <code>[Option]<[Square]></code>.
 *
 * This type is provided for C interoperability.
 * cbindgen cannot deduce that <code>[Option]<[Square]></code> can be represented by `uint8_t` in C, so we need to define the bridge type.
 * Users of this type should convert to/from <code>[Option]<[Square]></code>.
 *
 * See: <https://github.com/eqrion/cbindgen/issues/326>.
 */
typedef uint8_t OptionSquare;

/**
 * A position with its move sequence omitted.
 *
 * This data is insufficient for complete legality checking (such as repetition checking),
 * but in most cases it suffices. If you need a complete legality checking, use `Position`.
 *
 * TODO: describe exactly when a position is considered valid
 */
typedef struct PartialPosition {
  Color side;
  uint16_t ply;
  struct Hand hands[2];
  OptionPiece board[81];
  struct Bitboard player_bb[2];
  struct Bitboard piece_bb[14];
  OptionCompactMove last_move;
  OptionSquare king_square[2];
} PartialPosition;

/**
 * A piece + who owns it.
 *
 * [`Piece`] and <code>[Option]<[Piece]></code> are both 1-byte data types.
 * Because they are cheap to copy, they implement [`Copy`].
 *
 * Valid representations are `1..=14`, and `17..=30`. `1..=14` represents a black [`Piece`] and `17..=30` represents a white [`Piece`].
 * Examples:
 * ```
 * use shogi_core::{Color, Piece, PieceKind};
 * assert_eq!(core::mem::size_of::<Piece>(), 1);
 * assert!(Piece::B_P.as_u8() <= 14);
 * ```
 */
typedef uint8_t Piece;
#if defined(DEFINE_EXPERIMENTAL)
/**
 * How many elements should an array indexed by [`Piece`] have?
 *
 * Examples:
 * ```
 * # use shogi_core::{Color, Piece, PieceKind};
 * // values is long enough so values[piece_kind.index()] never panics
 * let mut values = [0; Piece::NUM];
 * values[Piece::W_P.array_index()] = -10;
 * values[Piece::B_L.array_index()] = 25;
 * values[Piece::W_PR.array_index()] = -155;
 * ```
 * This item is experimental: it is subject to change or deletion.
 */
#define Piece_NUM 31
#endif

/**
 * A square.
 *
 * [`Square`] and <code>[Option]<[Square]></code> are both 1-byte data types.
 * Because they are cheap to copy, they implement [`Copy`].
 */
typedef uint8_t Square;
/**
 * How many elements should an array indexed by [`Square`] have?
 *
 * Examples:
 * ```
 * # use shogi_core::{PieceKind, Square};
 * // values is long enough so values[square.index()] never panics
 * let mut values = [None; Square::NUM];
 * values[Square::SQ_5I.array_index()] = Some(PieceKind::King);
 * ```
 * Since: 0.1.2
 */
#define Square_NUM 81

/**
 * Finds all checks that are drop moves.
 */
struct Bitboard all_drop_checks_partial(const struct PartialPosition *position,
                                        PieceKind piece_kind);

/**
 * Determines if king is in check.
 *
 * Since: 0.1.1
 */
bool is_in_check_partial_lite(const struct PartialPosition *position);

/**
 * Checks if the normal move is legal.
 *
 * `piece` is given as a hint and `position.piece_at(from) == Some(piece)` must hold.
 */
bool legality_normal_check(const struct PartialPosition *position,
                           Piece piece,
                           Square from,
                           Square to);

#endif /* shogi_legality_lite_bindings_h */
